# Symfony mantenible y escalable

by Dani Santamar√≠a, Jabvier Ferrer ‚Äì CodelyTV

------

> Aprende herramientas y pr√°cticas con Symfony para conseguir una mayor mantenibilidad y escalabilidad de tus aplicaciones.

**Available resources**

-  [Course materials](https://pro.codely.tv/library/symfony-mantenible-y-escalable-127478)
-  [GIt reposiroty](https://github.com/CodelyTV/symfony-maintainable-scalable-course)

üè∑Ô∏è Tags: `course`, `2021`, `codelytv`, `symfony`, `backend`, ...

------

## Introducci√≥n, historia, filosof√≠a, arquitectura Symfony

* Se dan notas hist√≥ritcas sobre Symfony. Aqu√≠ unas notas
* Uso del patr√≥n DataMapper reemplazando al ActiveRecord utilizado inicialmente
* Symfony Flex
* Definici√≥n de servicios v√≠a autowiring
* Parametrizaci√≥n v√≠a variables de entorno
* Symfony trata de segregar interfaces con prop√≥sitos muy concretos, permitiendo que los clientes puedan usarlas y expandirlas si quieren. Un ejemplo es `\Symfony\Component\HttpKernel\Kernel`
* Componentes Symfony EventDispatcher y Symfony Messenger
* Iteraci√≥n del framework para permitir difinici√≥n de todo como servicios, incluso los controladores. Era t√≠pico el buscar c√≥mo definir controladores como servicios
* Uso de event dispatchers de Symfony y middleware de Laravel

![Event dispatcher and middleware](.assets/symfony-escalable-y-mantenible-codelytv.md/event_dispatcher_and_middleware.png)
([Referencia](https://www.researchgate.net/figure/Event-dispatcher-and-middleware_fig2_330656531))

* Notas de arquitectura
  * Uso de patr√≥n [Front Controller](https://martinfowler.com/eaaCatalog/frontController.html) para manejar todas las peticiones partiendo del mismo punto
  * La p√°gina del curso tiene un [resumen](https://pro.codely.com/library/symfony-mantenible-y-escalable-127478/308903/path/step/129421021/) del flujo por escrito
  * Componentes principales: [HttpFoundation](https://symfony.com/components/HttpFoundation), [HttpKernel](https://symfony.com/doc/current/components/http_kernel.html), [EventDispatcher](https://symfony.com/doc/current/components/event_dispatcher.html)


![Symfony request handling](.assets/symfony-escalable-y-mantenible-codelytv.md/symfony_request_handling.png)

## Migraci√≥n progresiva del Legacy a Symfony

* La clave del proceso es hacerlo progresivo. No tratar de reemplazar el sistema legacy por el nuevo de un solo golpe, sino ir haciendo cambios y despliegues progresivos
* Explican 2 posibles estrategias para ir reemplazando el legacy por Symfony [*sidenote*: <unque siempre hay m√°s alternativas. Elegir una u otra puede depender de qu√© tipo de legacy hhay que migrar o de su complejidad]

###¬†Fallback al front controller Legacy

* Se crea un nuevo proyecto Symfony totalmente separado del legacy
* El front controller de Symfony es el punto de entrada a la aplicaci√≥n (`public/index.php`)
* A grandes rasgos, se modifica el front controller de tal modo que todas aquellas rutas que dan una respuesta 404, se ejecuta el controlador legacy correspondiente para que maneje la petici√≥n
* El controlador legacy actuar√≠a de fallback en este caso

### Cargar rutas Legacy

* Aqu√≠ se a√±aden las rutas legacy a la instancia de RouteCollection que Symfony crea en base a la configuraci√≥n de rutas del nuevo proyecto
* Para las rutas legacy, se crea un nuevo custom Symfony Loader que [se etiqueta](https://symfony.com/doc/current/routing/custom_route_loader.html#creating-a-custom-loader) en el inyector de dependencias como tal para que sea cargado
* En este custom Loader, es donde se crea el nuevo controlador para manejar las rutas legacy, asociando estas rutas legacy a un nuevo controlador manejado en la aplicaci√≥n de Symfony
* En este controlador es donde se maneja la ejecuci√≥n del controlador legacy para cuando esta ruta no tenga todav√≠a un reemplazo en la configuraci√≥n de rutas del proyecto
* Aqu√≠ ya no hablamos de fallback, pues las rutas legacy son ahora manejadas como rutas del proyecto Symfony al mismo nivel (e.g. se pueden ver utilzando el comando `debug:router`)

## Configurar y adaptar Symfony para mejorar la mantenibilidad

* Detalles sobre el Contenedor de Inyecci√≥n de Dependencias de Symfony ([componente](https://symfony.com/doc/current/components/dependency_injection.html))
* Creaci√≥n de distintos Kernels para distintos front controllers para distintas aplicaciones desarrolladas en un √∫nico monorepo
* Uso del autoconfigure de Symfony y la opci√≥n `_instanceof`del contenedor para tanguear servicios delegando en Symfony sin tener que hacerlo manualmente. [Autoconfiguring tags](https://symfony.com/doc/current/service_container/tags.html#autoconfiguring-tags) y [Reference tagged services](https://symfony.com/doc/current/service_container/tags.html#reference-tagged-services)

## Optimizaciones habituales en peticiones HTTP

### Gesti√≥n de errores

* Control de una excepci√≥n no capturada transform√°ndola en una respuesta controlada con un determinado HTTP status code

* Cada vez que en un controlador hay que a√±adir el control de una nueva excepci√≥n, hay que modificar la clase del controlador. Si se quiere aplicar SOLID aqu√≠, se podr√≠a no modificar la clase y controlar las excepciones de todos los controladores en un punto com√∫n

* Varias formas de hacerlo. La manera propuesta

  ```php
  abstract class ApiController
  {
      public function __construct(
          // (...)
          ApiExceptionsHttpStatusCodeMapping $exceptionHandler
      ) {
          each(
              fn(int $httpCode, string $exceptionClass) => $exceptionHandler->register($exceptionClass, $httpCode),
              $this->exceptions()
          );
      }

      // (...)

      abstract protected function exceptions(): array;
  }

  final class CoursesCounterGetController extends ApiController
  {
      public function __invoke(): JsonResponse
      { /* (...) */ }

      protected function exceptions(): array
      {
          return [
              CoursesCounterNotExist::class => Response::HTTP_NOT_FOUND,
              // ...
          ];
      }
  }
  ```

  ```php
  final class ApiExceptionsHttpStatusCodeMapping
  {
      private const DEFAULT_STATUS_CODE = Response::HTTP_INTERNAL_SERVER_ERROR;

      // (...)

      public function statusCodeFor(string $exceptionClass): int
      {
          return get(
              key: $exceptionClass,
              collection: $this->exceptions,
              default: self::DEFAULT_STATUS_CODE
          );
      }
  }

  final class ApiExceptionListener
  {
      public function __construct(private ApiExceptionsHttpStatusCodeMapping $exceptionHandler)
      {
      }

      public function onException(ExceptionEvent $event): void
      {
          $exception = $event->getThrowable();

          $event->setResponse(new JsonResponse(
              [
                  'code'    => $this->exceptionCodeFor($exception),
                  'message' => $exception->getMessage(),
              ],
              $this->exceptionHandler->statusCodeFor($exception::class)
          ));

          // (...)
      }
  }
  ```

  **ApiController**: Clase abstracta que usa el patron [template method](https://refactoring.guru/design-patterns/template-method) en el m√©todo exceptions para que los controladores definan el un diccionario que mapee la excepci√≥n con un c√≥digo de respuesta HTTP

  **ApiExceptionsHttpStatusCodeMapping**: Maneja el mapeo de c√≥digos

  **ApiExceptionListener**: Symfony EventListener donde se hace uso de la clase anterior; reacciona a las excepciones para construir una respuesta de error HTTP

### Optimizar el rendimiento

* Ejemplo de enviar un email tras devolver la respuesta

### **Procesado de eventos de dominio en Event Subscriber**

* Hacer uso del `kernel.terminate` para todo lo que no sea nbecesario procesar para darle la respuesta al usuario
