# Contributing to an Open Source Project on GitHub

by Kamran Ayub



* [An example open source project for this course, for demo purposes](https://github.com/wired-brain/wired-espresso)

------

## Course overview

* Practical skills to become an effective contributor
* Threw a simulated project where we'll tackle common scenarios you're
* Major topics that will cover
  * Exploring projects that interest you
  * Identify and good first issues to work on communicating effectively and responsibly handling common pull request scenarios and following the user's issues and pull requests

## Getting Involved in an Open Source Project

* Contributing to open source is great for personal and professional growth
* Contributing doesn't just mean coding. Takes many forms
* Where to contribute?
  * Own projects, but not necesary if you don't have a specific one in mind
  * Learn how to find projects that interest you
* What to look for when on boarding to a new project
* How to perform a quick pulse check that will give you a sense of whether the project will be a good fit for you
* Benefits of Contributing to Open Source
  * Nearly all companies run on open source somewhere in their business
  * Personal Growth
    * Contributed. Open Source can Help You Grow Personally
    * One of the biggest benefits is the opportunity to give back to the community
    * Contribute to open source projects that have a real impact on people / help others
    * It gives you a space to experiment and grow your skills, learn new technologies and build your talent
    * It helps to find and meet other developers. Many projects have more than one maintainer
    * Popular projects have hundreds of regular contributors
      * As you contribute more and more to a project, inevitably, you'll start to develop relationships with maintainers and contributors alike
      * These kinds of relationships at riel value to your life and could open new doors you previously didn't think were possible
    * Move from a consumer role, to a creator one
    * Discover something you enjoy working on. What are your hobbies? Skydiving, video games, board games, rock climbing, hiking? There are open source projects related to all
  * Professional Growth
    * Finally, contributing to open source can be financially rewarding when a project get sponsorship crowdfunding and makes a real impact on the broader community
    * Make your work experience portable. Which means that anyone could see your code, the way you interact with others and your experience
    * Open alternative paths to getting hired
    * Learn how to work effectively on a team
    * Develop interpersonal communication skills
  * In short, open source is an incredibly rewarding way to invest your time
* Understanding the Different Types of Contributions
  * Contributing is more than writing code
  * Three main contribution categories: Planning, social and development
  * Planning contributions
    * Deal mainly with helping to assist an issue management or helping plan new features
    * Helping fill gaps in the issues (missing information, provide reproduction cases, etc)
    * Providing feedback on usage and features
      * Some projects put out requests for comments (RFC). Common to need members of the community to weigh in on important new features or major changes
      * This is a great opportunity if you use a project heavily to provide input on its direction and influence development
    * Participating in community standups or planning sessions
  * Social contributions
    * Focus on the community, aspects of a project and marketing. Yes, even open source needs marketing
    * Open source software is still a product, and products need marketing so people know about and want to use them
    * Answer questions and help others
    * Write documentation or tutorials
    * Host events or help marketing efforts
  * Development contributions
    * The primary way to contribute to development is by implementing features or fixing bugs
    * Participate in code reviews, once you're comfortable contributing to the project. Helping to review code style, provide feedback or offer implementation advice, etc
    * Write process or workflows that can be automated. Helping to increase the productivity of everyone who contributes
    * Offer financial support, and I'm categorizing this as contributing to development because this helps support the developers and keep the project funded
  * This course is mainly gonna focus on contributing, and both the planning and development areas as well be looking at scenarios when working on issues and submitting pull requests
* Finding a Project to Contribute To
  * One option is the [Explorer feature](https://github.com/explore)
  * Browsing projects [by topic](https://github.com/topics)
  * Discovber projects [by collections](https://github.com/collections)
  * Find [trending projects](https://github.com/trending)
* Onboarding Yourself to a New Project
  * GitHub has help standardize a few key pieces of information across projects
    * Repositories could have a `.github` folder with all this kind of information (samples: [ionic](https://github.com/ionic-team/ionic/tree/master/.github), [symfony](https://github.com/symfony/symfony/tree/master/.github))
  * The most common ones are: the contributing guides, a code of conduct and licensing agreements
  * Contributing and Setup Guides (samples: [ionic](https://github.com/ionic-team/ionic/blob/master/.github/CONTRIBUTING.md), [symfony](https://symfony.com/doc/current/contributing/code/index.html))
  * Code of Conduct (samples: [ionic](https://github.com/ionic-team/ionic/blob/master/CODE_OF_CONDUCT.md), [symfony](https://symfony.com/coc))
  * Contributor License Agrrements (CLA) (samples: [ionic](https://github.com/ionic-team/ionic/blob/master/LICENSE), [symfony](https://github.com/symfony/symfony/blob/master/LICENSE))
    * [Software Licenses in Plain English](https://tldrlegal.com/)
    * An agreement between you and the company that owns the project that defines the terms of your contribution, such as assigning rights and ownership
    * It's really important to mention that if you are doing work on behalf of your company or even while at work, you may need to have your company's legal counsel look over the document and review it
  * Checking the Pulse of a Project
    * Before contributing to a project it's good to make sure the community around is healthy and supportive of new contributors
      * Is an important step if you're looking to get more involved on a project over time
    * What to whatch out for
      * Lack of contributing documentation. Make it harder to how to contribute, what's expected
      * No easily identificable issues for first-time contributors. Samples: use of "help wanted", "good first issue" or labels designed like that
      * Stale or outdated pull requests
    * Poor attitude or conduct amongst maintainers

## Preparing to Make a Contribution

* Demo: Working with a Fork Using [GitHub Desktop](https://desktop.github.com/)

* Demo: Working with a Fork Using the Command-Line

  * Clone a forked repo
  * Adding an upstream remote
  * Syncting upstream changes

  ```shell
  $ git clone https://github.com/ebarbeito/wired-espresso.git && cd $_
  $ git remote # origin
  $ git remote add upstream https://github.com/wired-brain/wired-espresso.git
  $ git fetch upstream master
  $ git log HEAD..upstream/master --oneline
  $ git pull upstream master
  $ git push origin master
  ```

* Shortcut command to keep all your git remotes up to date

  ```shell
  $ git remote update
  ```

  It will fetch both the origin and the upstream remotes

* Finding Work and Engaging the Team
  * Looking through the issues list to find some issues to work on and walk through some situations when you interest by a specific issue
    * Looking at an issue labeled witg "help-wanted". A maintainer usually wrote the issue requesting for changes (features, bugfixing, etc.)
      * Explain the context and/or the things are needed to be done
      * Should also give a proposed solution, how to make the change (if exists a clear path) or what to do
    * The same as before, but you wrote the issue with a change request
      * Maintainers can not be interested and close it
      * Or can be interested, they should give some guidance how is needed to make it happen, request a PR, etc
    * In the issue someone else said that he would like to work on this but it was several months ago
      * Leave a comment asking the other person: "Hi @johndoe, saw your comment and wondering ig you are still working on this?"
  * Before I go and start writing code, it's best to signal my intent to work on this issue. How to do it?
    * Add a comment: "Going to take this" → Avoid telling it in that way, cause maybe someone else is already working on it
    * Add a comment: "Is it available to work on" → Better
  * Drafting a Great Pull Request
    * Open a draft pull request anytime your changes aren't yet ready to be reviewed
    * A PR is the primary way you'll be getting feedback and engaging with the team on a new set of changes
    * Provide as much information as you can with a description and bulleted list of major changes
    * Make sure the link to the related issue if there is one
    * Optional: Include a checklist to track my progress
    * Ask any question or mention specific feedback needed. Include reviewers you have questions for reviewers
    * If you're changes aren't yet ready for review, be sure to open a draft pull request
      * Use the button "Draft pull request"
    * Read and follow the PR template if it's provided

## Collaborating Effectively on Pull Requests

* Dealing with Conflict

  * Alongside that, diversity of ideas and backgrounds will emerge. Conflict

  * Conflict in an open source project is not always a bad thing. Types of conflict

    | Good conflict             | Bad conflict                      |
    | ------------------------- | --------------------------------- |
    | Healthy debate            | Personal attacks                  |
    | Disagreement with empathy | Harmful or disrespectful language |
    | Difference of opinion     | Violent behaviour                 |
    | Constructive criticism    | Conduct violations                |

  * Sample in an opened issue with some change proposal (related with adding a dependency)

    * The scenario is a great example because tooling changes can often generate debate amongst contributors
    * Conflict appears: "I don't think we need yet another dependency"
    * A classic example of a maintainer opposing a new change they believe might inhibit the project in some fashion

  * Let's cover some tactics you can use to work through this conflict

    * The first instinct, when seen a comment that opposes your idea, might be to get defensive
    * Try asking a question instead. The impediment was not reasoned, so we want to get at the why
    * For example, I might ask: "Is there some overhead you are specifically concerned about?"
    * Just ask and try to listen
      * We can't be sure of the motivation behind
    * (...) he/she follows not convinced, doesn't want to get your point, or you think is not taking you into account, etc.
      * Uh, okay, that's frustrating. So, I'm going to give her/him a piece of my mind! $*#%&@!
      * Hold on. Okay, Okay. Wait a minute. Hold on. Take your hands off the keyboard
      * Sometimes it's just best to take a break and cool down when you feel the heat rising, that's a sign
    * Let me share a trick with you
      * My wife works with kids all day at school as a social worker, and she tells them that when they feel angry about something, ask themselves whether it's a little deal or a big deal
      * Asking yourself this question in the moment can help immediately ground you
      * Let's face it, someone not wanting to use a tool I like on an open source project is probably a little deal. Just that simple mindset shift can make all the difference
    * Let's refocus back to the first (more visceral) comment you wanted to post
    * Now that we've had our moment, let's think about what they're trying to say
      * Their argument is that there's already a code style guide people can follow. So why introduce yet another tool now?
      * Rewrite your own comment in order to focus on the ideas (avoiding the visceral parts). Because it will contain the key points you could focus on
    * In a worst case scenario, let's say he/she left a comment like where attacks are personal character and claims that by pushing our opinions on that we must hate the project and all it stands
      * Let you imagine what else someone could say that would be considered disrespectful or harassment
    * In this situation, it might be best not to respond and instead consult the code of conduct to report a violation
    * If a project has a healthy community, they would certainly take action against this kind of (harmful) conduct

  * The topic of communicating effectively is larger than the scope of this course

* Working with Code Reviews

  * PR are the primary way to get feedback on your contributions, and there's several features you'll likely used during the code review process
  * We initially opened this PR up as a draft because I had some work in progress (...) I've pushed those changes (...) so we can now mark this PR as ready for review
  * To do that, I'll scroll down here and click the button "Ready for review"
  * This doesn't necessarily notify the team that your PR is actually ready
  * I'm not going to tag maintainers within a PR comment, though. Instead I'll go back to the original issue and leave a comment there
  * It's possible that anyone who is interested in the issue is watching it as shown here on the right side
    * "Hi @johndow, I just opener a PR to #9 to address this issue if you'd like to take a look. Thank you"
  * Reviewers can leave suggestions which you can incorporate without going back to your local repositories
  * We can add suggestions to batch and then commit those added ones
  * Wait until the conversation is over, before resolving it
  * Leave comments to provide context or reminders

* Undoing or Reverting Changes

  * the team has asked us to revert some formatting changes we made unintentionally, and this demo will undo those changes using two methods the first method will look at is how to undo specific lines using interactive patching. And the second method is by undoing a commit using the get revert command on the command line were in our poll request branch. Now, the first method of undoing her formatting changes can be done using a less common but very powerful command. An interactive check out. What we're going to do is find the commit before the one we made formatting changes in we can use the get log dash Dash one line command to view the commit history of our branch. This will display a paged output from latest oldest commits. The one line argument displays a more compact output suitable to scan through quickly the commit where we added RV to logic is this one we want to copy the I d of the commit before this one because that represents the original file before our changes. Since the output is paged, we can hit the cuchi to quit it. Now we're going to do a bit of magic and check out that specific file within an interactive mode that will let us apply specific changes. We want to keep the dash p stands for patch because this is gets patching mode. We'll pass the commit we want to check out from and the specific file path the patch check out brings up an interactive session where it's displaying the difference between the old file with the old formatting style versus our newest file. But the changes we made, we essentially want toe on Lee, bring forward the old formatting changes but preserve all the other logic and behavior changes right now get is asking if we want to apply all the changes in the file, but we want to review them individually, so we'll press the S __ and hit enter to split the changes up into smaller hunks. Now we're being asked if we want to apply the specific change we're going to choose why to apply that change, which will bring forward the old code for the next change. Here again, we don't want to undo our logic changes, so we compress end to discard this change and the next few changes as well. Finally, we reach the end of the file and we do want to bring back the old formatting change so oppressed. Why, now that we've finished, let's review what the new changes will be using the get def command. The highlighted changes are the old formatting style, which means we successfully preserved our logic changes but discarded the new formatting changes. That whole process of going through each change may have seemed a bit advanced, but I wanted to show it to you because the second method will use involves a lot more cross checking and is prone to human air. It's actually what most people would probably do in this scenario, so let's see how it plays out. The first thing I'll do is reset my working tree by using get, restore and using the relative dot path, meaning to restore this whole directory. If I execute a get status, we can see that we ended our changes and we're now back to square one. Now we're going to try reverting the commit using the get Revert command, which might have been the first approach you would have taken. But it has a bit of a caveat. Let's see why I'll issue the get Log command once again and copy the commit We want to revert, which is the one containing our changes. Next, I'll type in the get revert command, followed by the dash and switch, which will not commit the changes yet. And I'll paste in the community. This will revert all files within the commit by default. So now if I executed get status will see that there's a change. The caveat I mentioned is this bit right here. Notice where it says it's auto merging these changes and that there's a merge conflict because this commit happened previous to emerge conflict. We're going to see something we may not expect when we view this file in visual studio code, the first thing we'll see are some conflicts within the file. We're trying to revert. Let's try to resolve it. So we'll accept the current change here because this is the new property name. And then down here once again, I'll accept the current change. But do you notice something now? We're missing this variable here. That was in the current code. If we look around the rest of the file, we do see that the formatting changes were all reverted properly. But now we need to go and reference the latest code in the pool request to fix this issue because I might not remember where that version came from and we don't want to accidentally introduced a regression. I'll go ahead and fix this, then, by adding version to this expression right here. Once I do that, I think that the file looks right. I'll stage it and then click it once more to see the diff. OK, I think that this looks right. All the formatting changes have been undone and the logic was preserved. The two approaches we walked through accomplish the same goal, but they each had some tradeoffs. When we did an interactive patch, we had to pass in the previous commit to the one that we actually wanted to revert, and we were able to see every change and choose what to apply. When we use get revert it auto, merge some changes and we needed to add code back that was removed. I wanted to show you both options so you could choose whatever approach you think suits the problem you're facing. At this point, we can finish reverting the changes. It's all type and get status and get all. Tell us we're in the middle of a revert and need to execute, get revert Death stash. Continue to finish its allowing me to edit the message before commits. So I'll just write it out and exit now that the changes in Let's push it to our fork back in the browser. The new changes reflected here. Let's go back to the original comment that requested these changes and reply back, saying that the formatting changes should be undone with the magic of editing, they've replied, and they've also resolved the conversation. As we review our polar quest and scroll down, it looks like we've received another request by wired brain. They're asking us to perform a re base and clean up our commit history. I wonder what that means

Rewriting History and Fixing Mistakes
[Autogenerated] have you ever wanted to become a time traveler and rewrite history? Well, I have good news and bad news. The bad news is that you can't relive the classic eighties movie back to the future. But the good news is you can rewrite, get history in this demo will learn about re basing and how to perform one using it to interactively squash your commits if we want. We'll also go back and fix typos by amending, commits and will even become a get jet I by rewriting public history using a force push. Trust me, it's just a school. All the topics will discuss in this video are covered in greater detail in the rewriting Get history course on plural site. Instead of explaining all the mechanics will look at it from a contributor perspective, what do you need to know? From a practical standpoint, when working on an open source project, let's get into it. Wired Brain has asked us to re base our commits to clean up our history. Why would they ask us to do that well in the real world and maintainer probably wouldn't ask you to clean up your history after the fact they'd request that you keep it clean before pushing. There's an important reason why it should be before pushing. It's because you should never rewrite public history. What I mean is, as soon as you push your commits to a remote repositories, those commits are considered shared with the world. Five seconds after you push, someone may have cloned your depository, and if you rewrite that public history the next time they pull down your commits, the repositories will explode. Well, not literally, but it's very painful to deal with rewritten history. But even though I just said we shouldn't do this, we're going to do it anyway for the sake of illustration, because the world isn't perfect, and sometimes you just need to rewrite public history. What we'll do on our machine is performer re base. A re base allows you to edit a history of commits to change their commit messages, squash them together, split them apart, reorder them or remove them all together. We'll start by doing a get log with one line switch. To see a compact view of our history In this branch, you can start a re base at any commit and will include all the commits after it, since we want to clean up the history of our PR and make it more succinct will choose the commit right before our first commit in the PR, which is this one. All the commits after this one were part of our poll request branch and that's what we want to clean up. I copied the Shah and now all type get rebased dash I and paste it the dash. I will start an interactive rebased session. Let's check it out. This will bring us into our terminal editor of choice and present us with a file we need to edit. This is the re base to do file and it allows us to customize what get will do during this re basing session. The rewriting get history course dives deeper into all the features of re basing. So what I want to focus on is what I would do to clean this up. As you can see, we have a lot of commits here. I don't think that we need all of them. It makes the history hard to read. What we'll do is go through each commit line by line and choose what we want to do for this First commit, we're going to reword it so that we try to match the commit convention that this project uses. Then for the next few, we're gonna squash these together because they're kind of related to adding tests. When you choose to squash, it will melt, the previous commits together and we need a base commit. So add tests will be our base and we'll be able to edit the message later. This next mitt looks fine, so I'm not going to change it and this commit, I'm going to reword it once again to match our convention, and this commit message isn't very specific. So again, I'm going to reword it. This commit looks good, but the next one I'm also going to reword because Revert doesn't really make sense. Now that we've told get what to do with each commit, I'll save the file and that will start the re basing process as get goes through each step. It will stop at the places we told it. We wanted to pause. Remember, in this commit, I've specified I want to reward it to match the convention, so I'll try to do that Now, this is how we edit the squash commit notice that there are five commits that are going to be melted into one. So I'm going to use the last message because that's probably the most descriptive for this. Commit once again, we need to match the commit convention for this commit. We want to be more specific, so I'm gonna add some more clarity to it. Okay, It looks like we got there most of the commit messages, but that last one we wanted to reward is actually causing emerge conflict. So I'm going to hop into visual studio to resolve that. Now that I've resolved the merge conflict, we can continue the re base. The re base is continuing on the next commit, but I don't need to change this one, so I'm going to skip it. And now, finally, I met the last commit and this is what I want to clean up. Because reverte ad condition for V two doesn't really describe what the committee is. We're actually just undoing the formatting changes. So that's what I'm gonna change it to. All right. After all that, we should have a newly rewritten history. Let's execute, get log one line once again to view it. Okay, look att that we have a nice clean history. Oh, hold on a second. That last commit I just did, Has a typo. Ah, guess we need to re base again. This time we can actually use the get commit command and past dash, dash Amend. Executing this will allow us to amend the last commit we made on this branch which allows us to modify the message or the files inside it. Let's save and exit now if we execute, get log again. The typos been fixed. Now it's time for us to push these changes up to our fork. Let's try using, get push like we normally would. Oops, It looks like there's an air. Get a saying we're behind on our commits and we need to integrate our remote changes. What's happening is that we've rewritten our commit history so remote doesn't match our local history anymore. This is why rewriting public history should be avoided. We'll need to force push our changes. Since we understand the consequences, I'll suggest that we use the force with lease option, which is a safer force push as it'll make sure that our local branch has all recent commits pulled in from the remote first. This time it succeeds. Let's hop over to the browser to see what we've done scrolling down. We should see our new history. In fact, get hub is showing that we forced push to the branch. I guess we're time travelers now because we just rewrote history. And, like time travelers, we probably triggered some ripple effects to any other contributors that pull down our branch.

Recovering from a Public Rebase
[Autogenerated] Meanwhile, while our time traveler has stepped out for coffee, we're going to switch perspectives to demonstrate how rewriting public history might have affected another contributor, cup of Joe and how we can recover from it. He switches to his terminal where it's obvious Joe really just loves coffee. Look at that brown color scheme. I guess I don't blame him. All right. First Joe reviews his status using the get Status Command. It appears Joe's working on a change to the read me file. I wonder what that is. Well, never mind that. The fact is that Joe has some work in progress and now he needs to pull down a rewritten history. You can see that get is saying that his branch and the remote branch, which is actually my branch, have diverged and have one and one different commits each, respectively. I think that's gonna mean there's gonna be some issues to handle this. Zhou will try executing a get pull. It looks like it worked. But just in case Joe checks the history using get log. Look at that. It looks like there are two commits with basically the same name. Well, that first commit is one of the changes we made when we force pushed. This is what can happen when someone rewrites public history, the old commits become duplicated and other people's repositories, even if it seems like it worked. If Joe pushes his commits, it'll result in a duplicated history joke and try to fix this with the get re base command. But this time passed the upstream, remote branch and his local branch to re base against it, saying that he has on stage changes, he can either commit them or stash them. He'll stash them for now. Hoops. He missed a push. Now his working directory should be clean and he can try to re base again. Okay, there were a few things that happened. The first thing get Did is rewound his branch to try and replay his commits. On top of the remote changes, he was able to find changes and merged them without issues. This should have fixed his commit history, and Joe checks by doing get log once again and sees that he removed the duplicate history entry. Let me rewind time a bit so we can see another way to approach the problem that might be easier if you already know to expect to deal with force Post changes This time Joe will use the get pull command, but we'll use a special argument. Dash Dash Re Base, which will tell, get to automatically try and re base again. Joe needs to commit or Stashes changes. This time, Joe commits his changes. Now he tries again. It looks like it's succeeded. But did it really Joe checks get log. And sure enough, there aren't any duplicate history entries. We see his commit secret. Read me updates come after our force push commit where I change the commit message. Re basing is not quite a simple concept, and that's why we try not to rewrite public history because having to do this can be a pain. The official get manual has a section that explains this process in more detail. In case you ever stuck. Well, you need to know right now is that usually get pull rebates will work in most cases. Let's leave Joe alone now and return to our own pool request

Integrating Changes from Others
[Autogenerated] on a large and active open source project. There are several scenarios. You should know how to handle that well, covering this demo. First, we'll see why allowing edits from maintainers can be helpful during the pull request process. Next, we'll look at how to pull in changes from another users fork in case we need to base our work off of someone else's. Finally, we'll pull down a pull request directly into our local repositories, which you may need to do if a user has deleted their fork continuing from where we left off. Cup of Joe is a contributor on the project, and it appears he added some documentation Tower pull request. How was he able to do this when we created our PR, we glossed over one important option that is checked by default, and that's to allow edits from maintainers has shown here on the side what this allows is contributors with right access to a project to be able to push directly to the branch tied to the poor request. You have to opt out of it by default because in most cases there's no harm in allowing this. If you do run into a situation where this is being abused, you can turn it off by un checking this box. Once we disable this feature, cup of Joe can no longer push directly to our branch. Instead, he'll need to make changes in his own fork in a separate branch. A few minutes later, Cup of Joe's left a comment on our poll request explaining he no longer has access and that we should incorporate a new commit he's made to the documentation. As part of this PR, he's linked to the commit with the changes following the link brings us to cup of Joe Zone fork of the project. Our goal is to merge this. Commit into our own poll request branch before we jump into the command line. We need to note down the branch these changes air contained in which you can see here. We'll need this later. Back in. Our terminal will start by pulling in our latest changes, which should pull in cup of Joe's. Commit to our branch denoted by this change to their read me listed in the output. Next, can you take a guess as to how we'll pull in changes from cup of Joe's Fork So far, we've mainly dealt with upstream in origin. But now we'll have to add a new remote. We'll use the get remote. Add command, naming a remote after wired cup of Joe and typing in the euro of his fork. Which we got from the kid, Huh? B Y next will make sure all our remotes are up to date by issuing the get remote update Command. Remember, this doesn't pull anything into our branch. It only fetches history and get reps available to check out to merge. Cup of Joe's changes into our branch will use the get merge command and then pass the wired cup of Joe remote name we just made, followed by the branch. Has changes are contained in which we noted earlier hoops. I think I missed a slash there since we just issued Get remote update above. We've already fetched all the changes. So I'm using get merged for the sake of illustration. Just so you're aware of the distinction. All right. Now, after executing this, get is displaying that they're read me was updated and the operation succeeded. If we execute, get status now, we'll see we're ahead by a few. Commits which means we're ready to push once more to update our poll request. After we pushed our changes to the pool request, we'll see them reflected here to follow up, Believer replied. A cup of Joe saying we integrated his changes a few minutes past and after we refresh the page. Cup of Joe has left us a comment explaining that we missed a new committee he just pushed and that he's open to PR, but he's accidentally deleted his fork. Losing the changes. Wow, cup of Joe. You're really not making this easy. We now need to recover the commit to include in our PR, but how can we accomplish that if cup of Joe's fork is deleted? Luckily, get up saves p ours in the main depository and allows us to check them out directly. We can click on couple of Joe's linked PR here. Which brings us to his changes. To check this out directly onto our local machine, we're gonna need to do a bit of a trick. We're going to execute a kind of scary looking get fetch command. Let's break it down. We start by fetching from the upstream, remote specifically and then we'll specify a special ref name that get abuses for pull requests, starting with Pol Slash followed by the P. R i D and then the head. Ref, This ref represents the PR get ref, which holds all the commits that have been pushed to the repositories after the colon. We provide a local branch name to create That represents this PR so we can name it anything we'd like. What's interesting about this is that this is read only we can't actually push back to the PR. Now, at this point, we have the pull request locally, let's see what get status says we're still on our poll request Branch will merge the branch into our current pull request branch using the get merch command, we now have our PR updated with another Piers changes. How cool is that? Let's issue a final get push Command to push these changes back up. Okay, there we can see the new commit was just added. We can now follow up with cup of Joe and let him know we've successfully managed to invoke the correct get incantations to make this complicated scenario work. Who I think we're done right? I can only hope Let's wait and see what the maintainers say about our p R. Now

Splitting a Pull Request Apart
[Autogenerated] in this demo will look at a scenario where we need to split apart of pull request and bring specific commits into a new PR. There are three approaches will look at that are commonly used. First, we'll learn how the get cherry pick command lets us pull specific commits into a new branch. Then we'll see how toe on Lee Cherry pick specific files from a commit finally will examine another approach to split a large PR by creating and merging sequential branches. We left off integrating some documentation changes into our PR, and we were waiting for feedback. It looks like wired cup of Joe approved the changes and then turned it over it a wired brain. While we were waiting, we were browsing the repositories and we checked back on the issue. We commented on in a previous video issue, Number two, where we asked if cup of Joe was working on it. As it turns out, we didn't get a response. After a few days since we already had a PR open, we decided to address this issue within our existing PR and push those changes. As you can see here. Turns out that wired brain has left another comment requesting that we take these new changes and move them to a supper PR. They explained that this PR is tied to a specific issue, and the other changes are for a different feature, so it's best to keep them separate. That makes sense. But how do we handle that? We have some extra work to do. The first approaches, the one I use most commonly to do this, and it's called cherry picking. Cherry picking works like this. Let's say you have a branch that was based off master. Each of these circles represents a commit the dark one on the left being the first commit that master was pointing at the light gray commits were added later, and the orange commit is the current head Commit. Now let's say we have an entirely separate branch, which could be based off master or any other base. Cherry picking allows us to take any commits that exist and upend them onto another branch like a clone and push operation. Notice how the two commits were appended to the new branch. So the last cherry pick commit is the new head, and importantly, the original commits. We cherry picked remain in place. Cherry picking does not rewrite history in our terminal. I'm currently on our PR branch. Let's look at the recent history so you know what I did since you last saw me? I pushed to commits. Here, these two commits are related to another Get hub issue and need to be pulled off this branch into another. To begin the cherry pick operation will switch back to our master branch and per usual, we need to get into the habit of making share branches up to date, so I'll pull and push any changes that need to happen. We'll create a new topic. Branch named after issue number two. We're now in a fresh branch will choose the Commit to Cherry pick using the get cherry pick command. It's best to cherry pick and order. So scroll up and copy the first unrelated commit hash here and then paste it into this cherry pick command and execute it. Now if I logged the history again, we'll see our new commit was added. What about the other? Commit. There's a small problem with it and that it contains a change I want to keep in the other branch but discard in this branch will execute get cherry pick again. But this time passed the dash and argument for no commit, which will pause the cherry picking process so we can modify the working tree. Let's issue a get status. And what I want to note here is that I also changed the p I. D file in this committee. This is the change I don't want to my new branch. In fact, it has a merge conflict, so we want to get rid of it. We only want to keep the reservoir dot tests change. So what I'll do is discard all the changes in that file using get restore and passing the file path. Well, first, I actually have to remove it using get Har M. So let's do that quick and then I'll try again. It looks like it might be removed already, since I just removed the file. It's marked as deleted, but we want to restore what its previous status waas. So we'll use get restore Dash Dash staged to restore the file back to its stage version and then check on it again. Finally, we can execute our original get restored command we were trying to do to discard the changes. And when I checked the status again, I shouldn't see any entry for its source. P i. D d. T s. Now we can commit this change just by itself. Let's check our local history. Perfect. We have our original cherry pick from before and then we have our modified commit. Let me clear my screen. Quick to finish off. We need to clean up the original branch we split off from. I'll quickly switch over to the original branch and look at the get log. I would like to revert thes two commits here, but preserve the changes to the P i. D. File. To accomplish this all issue a get revert command passing the desh and argument to pause and edit the working tree and then passing a range of commits. The first commit is exclusive, meaning it will revert to commit right after it and then inclusive up to the last commit. I specify. I paused the river because we want to keep the change we made to the P I. D file. Let's look at the get status. We can see the P i. D file has been staged. So let's onstage the file and then all discard the changes. We only want to revert the reservoir related changes, and now we successfully removed it from the revert. So now we can continue the revert process. I'll change the commit message slightly, and then I'll save and exit will push these changes to our poor request, which will revert the changes we just split off. Cherry picking is an extremely useful command in situations like this, but there's a hidden assumption to using it. It requires your commits to be neatly organized and free from intermingled changes. Sometimes this isn't the case, and you may have large commits that have many changes that could be unrelated. In this case, we could use a different approach. We could pick specific commits that represent logical places to split apart. This is called sequential Branching. We start again with the original branch containing commits. First, we'll start by identifying the earliest commit where we want to split the branch up. This commit will be the base of a new branch we create so will contain the commits that come before it. We can then do the same thing with the source branch, choosing to commit to split from and making yet another branch. We would continue doing this until no more commits or left. This allows us to submit separate pull requests for each of these branches, but it also means they must be merged sequentially since they build off each other for our scenario right now, it wouldn't make much sense to take a sequential branching strategy. But if you have a large PR closing it and submitting successively smaller p, ours that build on top of each other is certainly a viable way to split it apart. The best thing you can do, though, is to try and organize related commits and December P ours Initially. That way you won't have to split apart a large PR to save some time. I've gone ahead and opened our new split polar quest and filled out the PR template as well as reference the other poor request. Okay, we've successfully split off changes from the PR so they can be reviewed separately

Checking, Merging, and Closing Pull Requests
[Autogenerated] we're ready to finalize our poll request after making all the requested changes in this demo will make our poll request past the required status checks. See how we could merge a pull request if we have access, clean up after ourselves by deleting stale branches and finally will cover some etiquette to follow when closing a PR. I have our poll request up in my browser, and as we can see here, we have one last elephant in the room to address. The whole time we've been working on this PR, I've glossed over this section that says checks this list any workflow or status checks that get run automatically for pull requests and displays whether or not they've passed Wired Brain has commented, saying they think some tests are broken and we should check it out in open source projects. It's common for teams to set up automated tasks like continuous integration, continuous delivery, glinting code coverage or other checks that can prevent your poll request from being ready. For example, in this project, I've set up some get hub actions to build and test the coat. If we click the details here for this line item, it brings us to the checks tab in the UAE, which displays the different checks that are running and their output. RPR has been failing, and now we can see this output to drill down and see what happened. Notice this aggregated summary right here where get Hub is pulling out important messages. It seems like we have a typescript heir to fix, which involves making that required change and pushing it back up to the PR through the magic of video editing. I'll go ahead and fix the issue so we can see what happens when the check runs again. As soon as my changes air pushed, we can see the progress of the new check. It's building and testing our code while it does its thing, Let's go back to the poor request view and scroll back down to the checks area from a contributing perspective. If a cheque fails, you might need to look at the output to see what your changes impacted. If any of it is confusing, be sure to ask for help to determine the cause. Sometimes a check may fail in a way that's unrelated to your changes. Look at that. The check has passed. Now we can wait for wired brain to fully approve our PR and will be nearly done. We didn't have to wait. Long wired brain has approved our PR. It's time to merge. If you're an external contributor, you'll likely not need to worry about this as much because you'll see this message here about not having right access to the repositories. However, if you do have access, it's good to know the various ways of PR can be merged. I've switched browser windows and now I'm logged in as wired brain. I see a button here that allows me to merge the PR. Right now, this button is defaulted to squash and merge, and I can click this arrow next to it to show the other possible options. Squash and merges a common preference among teams since it creates a clean, commit history by squashing all commits from your polar quest into one single, commit to the base branch. Other teams prefer a merge commit which preserves your commit history and creates a final merge. Commit in the base branch. This last option is a re base. Emerge a re basin, merge ads, all commits from the polar quest onto the base branch individually preserving history without Emerge. Commit for more information about how these different methods work. You can refer to the pull request from start to finish course as wired brain. Let's squash and merger this PR one quick tip here get Hub will default this message to include all the commit messages in a list. I always dislike this because it's hard to read. Instead, I come up here and copy the changes section from the PR body, then go back and paste that into the commit message box. This keeps the squash commit message nice and clean, with a clear description of the changes. All also edit the commit title to follow the project conventions. Once done. Ah, click confirms question. Merge. Since we merge the PR as wired brain, I'll go back and view the pull requests to see what it looks like from my point of view as a contributor. Notice how get her prompts us to delete our branch. This is a good practice. Otherwise you'll start to have a growing number of stale branches living in your fork. Let's go ahead and click the delete button. We should do the same in our local repositories. Well, sometimes it can be useful to keep stale branches around for reference, but in many cases we can safely remove them. First we'll switch back to the master branch, and then we'll use the get branch command and pass the Dash D argument to delete our old branch. And it looks like it worked. But it also threw a warning, saying the branch hasn't been merged ahead yet. This is one caveat of the squash and merge approach for polar quests. Since getup doesn't create emerge, commit, there's no physical way. Get contract that a branch was merged. As the commits are unrelated, it's still deleted the branch, so we don't necessarily have to do anything differently. But when dealing with squash emerge, this is probably something you'll encounter. So it's good to be aware there will be some cases where you might choose or be required to close a pull request. It's OK to close a pool request if you made a mistake and want to open a separate PR in cases where you aren't sure if you can finish working on a P R, it might be best to keep it open to allow other contributors to help. Maintainers can always close. P. R's of it makes sense When you close a PR, you should provide a reason or linked to another related issue or pull requests so others understand why it was closed. If you open another PR after you leave a closing comment, I advise linking back to the original so that getup displays a link like this to the new PR after your closing comment.

Summary
[Autogenerated] this module walked through many different scenarios you might encounter when collaborating on a contribution to an open source project, we learned that healthy conflict can lead to a better way forward for a project. Collaborating on an issue can at times get messy. Get is a powerful tool, but sometimes you just don't know what to use when you get stuck throughout the module. I tried to demonstrate that keeping your work tidy and organized makes for an easier time in cases where you have to go back and split apart, work or fix mistakes. We use descriptive branch names, commit messages and tried to keep work scope to specific issues on pull requests. Spending time on the details will help you save time and headache down the road as you work on more complex changes. Let's explore the ways, get hub. Social features can help us stay up to date with our projects issues and pull requests

## Staying Updated With Social Features

* Keeping updated on your interests
* Following a project by Stargazing and Watching
* Subscribing to issues and pull requests
* Following and unfollowing users
* Setting your activity status
